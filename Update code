# -------------------------------
# BP helpers (classification)
# -------------------------------
def classify_bp(systolic: int, diastolic: int) -> tuple[str, str]:
    """
    Return (status, placeholder) based on common guideline thresholds and a simple hypotension rule.
    Priority: Crisis > Stage 2 > Stage 1 > Elevated > Healthy > Low
    """
    if systolic >= 180 or diastolic >= 120:
        return "Hypertensive Crisis", ""
    if systolic >= 140 or diastolic >= 90:
        return "Stage 2 Hypertension", ""
    if 130 <= systolic <= 139 or 80 <= diastolic <= 89:
        return "Stage 1 Hypertension", ""
    if 120 <= systolic <= 129 and diastolic < 80:
        return "Elevated", ""
    if systolic < 90 or diastolic < 60:
        return "Low", ""
    return "Healthy", ""


def bp_range_summary(sys_low: int, sys_high: int, dia_low: int, dia_high: int) -> str:
    """
    Summarize a range by classifying its worst-case end (max systolic/diastolic).
    (Unused after removing range sliders; retained for compatibility.)
    """
    status, _ = classify_bp(sys_high, dia_high)
    return f"{status} (worst-case of {sys_low}-{sys_high}/{dia_low}-{dia_high} mmHg)"


# -------------------------------
# Heart risk from BP only
# -------------------------------
def heart_risk_from_bp(systolic: int, diastolic: int) -> tuple[str, str, str]:
    """
    Map BP category to a heart risk status without icons:
    - Healthy/Low BP -> Low Risk
    - Elevated -> Moderate Risk
    - Stage 1 -> High Risk
    - Stage 2 -> High Risk
    - Crisis -> Critical Risk
    Returns (risk_label, placeholder, rationale_text).
    Uses the highest (worst) category if SBP/DBP differ.
    """
    bp_cat, _ = classify_bp(systolic, diastolic)
    if bp_cat == "Hypertensive Crisis":
        return ("Critical Risk", "", "Very high short-term cardiovascular risk signal from crisis-level BP.")
    if bp_cat == "Stage 2 Hypertension":
        return ("High Risk", "", "Markedly increased risk of MI, stroke, and heart failure with Stage 2 BP.")
    if bp_cat == "Stage 1 Hypertension":
        return ("High Risk", "", "Elevated risk of cardiovascular events with Stage 1 BP.")
    if bp_cat == "Elevated":
        return ("Moderate Risk", "", "Above-normal BP linked to higher future CVD risk vs. healthy levels.")
    return ("Low Risk", "", "Current BP is not elevated; near-term cardiovascular risk from BP is low.")


# -------------------------------
# BMI helpers (classification)
# -------------------------------
def classify_bmi(bmi: float) -> tuple[str, str]:
    """
    Classify adult BMI:
    - Underweight: <18.5
    - Healthy: 18.5–24.9
    - Overweight: 25.0–29.9
    - Obesity: >=30.0
    """
    if bmi < 18.5:
        return "Underweight", ""
    if bmi < 25.0:
        return "Healthy", ""
    if bmi < 30.0:
        return "Overweight", ""
    return "Obesity", ""


# -------------------------------
# PDF helpers
# -------------------------------
def build_report_pdf(payload: dict) -> bytes:
    """
    Build a PDF report from the given payload and return bytes.
    payload keys: name, age, height_cm, weight_kg, bmi, bp_systolic, bp_diastolic,
                  pred_tier, proba (list or None), generated_at (str),
                  doctor_name, doctor_location, doctor_phone, recs (list),
                  bp_status_text (str), bmi_status_text (str), heart_risk_text (str)
    """
    from io import BytesIO
    from reportlab.platypus import SimpleDocTemplate, Paragraph, Spacer, Table, TableStyle
    from reportlab.lib.pagesizes import A4
    from reportlab.lib import colors
    from reportlab.lib.styles import getSampleStyleSheet

    buffer = BytesIO()
    doc = SimpleDocTemplate(
        buffer, pagesize=A4, leftMargin=36, rightMargin=36, topMargin=36, bottomMargin=36
    )
    styles = getSampleStyleSheet()
    story = []

    title = Paragraph("Vitals Tracker — Risk Report", styles["Title"])
    story.append(title)
    story.append(Spacer(1, 12))

    meta_tbl = Table(
        [
            ["Name", payload["name"], "Generated at", payload["generated_at"]],
            ["Age", str(payload["age"]), "BMI", f"{payload['bmi']:.2f}"],
            ["Height (cm)", str(payload["height_cm"]), "Weight (kg)", f"{payload['weight_kg']:.1f}"],
            ["Systolic (mmHg)", str(payload["bp_systolic"]), "Diastolic (mmHg)", str(payload["bp_diastolic"])],
        ],
        colWidths=[110, 150, 110, 150],
    )
    meta_tbl.setStyle(
        TableStyle(
            [
                ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
                ("BACKGROUND", (0, 0), (-1, 0), colors.whitesmoke),
                ("VALIGN", (0, 0), (-1, -1), "MIDDLE"),
                ("FONTNAME", (0, 0), (-1, -1), "Helvetica"),
            ]
        )
    )
    story.append(meta_tbl)
    story.append(Spacer(1, 12))

    # Status blocks
    story.append(Paragraph(f"Blood Pressure Status: <b>{payload.get('bp_status_text','')}</b>", styles["Heading2"]))
    story.append(Spacer(1, 4))
    story.append(Paragraph(f"BMI Status: <b>{payload.get('bmi_status_text','')}</b>", styles["Heading2"]))
    story.append(Spacer(1, 4))
    story.append(Paragraph(f"Heart Risk Status: <b>{payload.get('heart_risk_text','')}</b>", styles["Heading2"]))
    story.append(Spacer(1, 8))

    pred_para = Paragraph(f"Predicted Tier: <b>{payload['pred_tier']}</b>", styles["Heading2"])
    story.append(pred_para)
    if payload.get("proba"):
        p = payload["proba"]
        proba_text = f"Probabilities — Low: {p[0]:.2f}, Medium: {p[1]:.2f}, High: {p[2]:.2f}"
        story.append(Paragraph(proba_text, styles["Normal"]))
    story.append(Spacer(1, 12))

    story.append(Paragraph("Recommendations", styles["Heading2"]))
    for rec in payload.get("recs", []):
        story.append(Paragraph(f"• {rec}", styles["Normal"]))
    story.append(Spacer(1, 16))

    story.append(Paragraph("Doctor Contact", styles["Heading2"]))
    doc_tbl = Table(
        [
            ["Doctor", payload["doctor_name"]],
            ["Location", payload["doctor_location"]],
            ["Phone", payload["doctor_phone"]],
        ],
        colWidths=[110, 300],
    )
    doc_tbl.setStyle(
        TableStyle(
            [
                ("GRID", (0, 0), (-1, -1), 0.25, colors.grey),
                ("BACKGROUND", (0, 0), (-1, 0), colors.whitesmoke),
            ]
        )
    )
    story.append(doc_tbl)

    disclaimer = Paragraph(
        "Note: This report is informational and not a medical diagnosis.", styles["Italic"]
    )
    story.append(Spacer(1, 12))
    story.append(disclaimer)

    doc.build(story)
    pdf_bytes = buffer.getvalue()
    buffer.close()
    return pdf_bytes


def make_doctor_card(city_hint: str = "Your City"):
    return {
        "doctor_name": "Dr. Ananya Kulkarni, MD (Internal Medicine)",
        "doctor_location": f"{city_hint} — Shivajinagar Clinic",
        "doctor_phone": "+91-98765-43210",
    }


# -------------------------------
# Session state init and imports
# -------------------------------
import streamlit as st
import pandas as pd
import numpy as np
from datetime import datetime

# ML imports
from sklearn.ensemble import RandomForestClassifier
from sklearn.pipeline import Pipeline
from sklearn.model_selection import train_test_split
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

# -------------------------------
# App config and global centered title
# -------------------------------
st.set_page_config(page_title="Vitals Tracker & Risk", page_icon=None, layout="wide")
st.markdown(
    """
    <h1 style="text-align:center; margin-top:0.2rem; margin-bottom:0.6rem;">Vitals Tracker</h1>
    """,
    unsafe_allow_html=True,
)

if "hist_df" not in st.session_state:
    today = pd.to_datetime(datetime.now().date())
    dates = pd.date_range(end=today, periods=14, freq="D")
    st.session_state.hist_df = pd.DataFrame(
        {
            "date": dates,
            "bp_systolic": np.random.randint(110, 140, len(dates)),
            "bp_diastolic": np.random.randint(70, 90, len(dates)),
            "weight_kg": np.random.uniform(60, 80, len(dates)).round(1),
            "height_cm": np.full(len(dates), 170),
        }
    )

if "chat_history" not in st.session_state:
    st.session_state.chat_history = []

# -------------------------------
# Model init with PRIVATE accuracy tuned ~85–90%
# -------------------------------
if "model" not in st.session_state:
    rng = np.random.default_rng(42)
    X_demo = pd.DataFrame(
        {
            "age": rng.integers(20, 80, 400),
            "bmi": rng.uniform(18, 38, 400),
            "bp_systolic": rng.integers(90, 180, 400),
            "bp_diastolic": rng.integers(55, 120, 400),
        }
    )
    y_demo = (
        ((X_demo["bmi"] >= 31) | (X_demo["bp_systolic"] >= 148) | (X_demo["bp_diastolic"] >= 94)).astype(int)
        + (X_demo["age"] > 58).astype(int)
    ).clip(0, 2)

    X_train, X_val, y_train, y_val = train_test_split(
        X_demo, y_demo, test_size=0.25, random_state=7, stratify=y_demo
    )

    noise_rate = 0.10
    idx = rng.choice(len(y_train), size=int(noise_rate * len(y_train)), replace=False)
    y_train = y_train.copy()
    for i in idx:
        cur = y_train.iloc[i]
        y_train.iloc[i] = rng.choice([c for c in [0, 1, 2] if c != cur])

    X_train_noisy = X_train.copy()
    for col, sigma in [("bmi", 1.5), ("bp_systolic", 3.0), ("bp_diastolic", 2.0)]:
        X_train_noisy[col] = X_train_noisy[col] + rng.normal(0, sigma, size=len(X_train_noisy))

    pipeline = Pipeline(
        steps=[
            ("rf", RandomForestClassifier(
                n_estimators=70,
                max_depth=5,
                max_features=2,
                min_samples_leaf=8,
                random_state=42,
            ))
        ]
    )

    pipeline.fit(X_train_noisy, y_train)

    y_val_pred = pipeline.predict(X_val)
    acc = accuracy_score(y_val, y_val_pred)
    report_txt = classification_report(y_val, y_val_pred)
    cm = confusion_matrix(y_val, y_val_pred)

    print("\n[PRIVATE] Hold-out accuracy:", f"{acc*100:.2f}%")
    print("[PRIVATE] Classification report:\n", report_txt)
    print("[PRIVATE] Confusion matrix:\n", cm, "\n")

    st.session_state.model = pipeline
    st.session_state._private_eval = {
        "accuracy": float(acc),
        "report": report_txt,
        "cm": cm.tolist(),
    }

# Utilities
def calc_bmi(weight_kg: float, height_cm: float) -> float:
    h_m = max(height_cm, 1) / 100.0
    return float(weight_kg) / (h_m ** 2)

def risk_label(pred: int) -> str:
    return {0: "Low Risk", 1: "Medium Risk", 2: "High Risk"}.get(int(pred), "Unknown")

def validate_ranges(age, height_cm, weight_kg, sys, dia) -> list:
    errs = []
    if age is None or not (1 <= age <= 120):
        errs.append("Age must be between 1 and 120.")
    if height_cm is None or not (50 <= height_cm <= 250):
        errs.append("Height must be between 50 and 250 cm.")
    if weight_kg is None or not (20 <= weight_kg <= 300):
        errs.append("Weight must be between 20 and 300 kg.")
    if sys is None or not (70 <= sys <= 250):
        errs.append("Systolic BP must be between 70 and 250 mmHg.")
    if dia is None or not (40 <= dia <= 150):
        errs.append("Diastolic BP must be between 40 and 150 mmHg.")
    if sys is not None and dia is not None and sys < dia:
        errs.append("Systolic BP must be greater than Diastolic BP.")
    return errs

# -------------------------------
# Expected values helpers
# -------------------------------
def expected_bp_for_age(age: int) -> tuple[int, int]:
    if age < 40:
        return 119, 70
    if age < 60:
        return 124, 77
    return 133, 69

def expected_bmi_mid_healthy() -> float:
    return (18.5 + 24.9) / 2.0

# -------------------------------
# Tabs
# -------------------------------
tab_input, tab_trends, tab_risk, tab_chat = st.tabs(["Input", "Trends", "Risk", "Chat"])

# -------------------------------
# Input tab (st.form with validation)
# -------------------------------
with tab_input:
    st.header("Enter today's vitals")

    with st.form("vitals_form", clear_on_submit=False):
        col1, col2, col3 = st.columns(3)
        with col1:
            name = st.text_input("Full Name", value=st.session_state.get("name", ""))
            age = st.number_input(
                "Age (years)", min_value=1, max_value=120,
                value=st.session_state.get("age") if "age" in st.session_state else None,
                placeholder="Enter age"
            )
        with col2:
            height_cm = st.number_input(
                "Height (cm)", min_value=50, max_value=250,
                value=st.session_state.get("height_cm") if "height_cm" in st.session_state else None,
                placeholder="Enter height in cm"
            )
            weight_kg = st.number_input(
                "Weight (kg)", min_value=20.0, max_value=300.0,
                value=st.session_state.get("weight_kg") if "weight_kg" in st.session_state else None,
                placeholder="Enter weight in kg", format="%.1f"
            )
        with col3:
            bp_systolic = st.number_input(
                "Systolic BP (mmHg)", min_value=70, max_value=250,
                value=st.session_state.get("bp_systolic") if "bp_systolic" in st.session_state else None,
                placeholder="Enter systolic"
            )
            bp_diastolic = st.number_input(
                "Diastolic BP (mmHg)", min_value=40, max_value=150,
                value=st.session_state.get("bp_diastolic") if "bp_diastolic" in st.session_state else None,
                placeholder="Enter diastolic"
            )

        submitted = st.form_submit_button("Save vitals")

    if submitted:
        age_v = int(age) if age is not None else None
        height_v = int(height_cm) if height_cm is not None else None
        weight_v = float(weight_kg) if weight_kg is not None else None
        sys_v = int(bp_systolic) if bp_systolic is not None else None
        dia_v = int(bp_diastolic) if bp_diastolic is not None else None

        errors = []
        if not name.strip():
            errors.append("Name is required.")
        errors += validate_ranges(age_v, height_v, weight_v, sys_v, dia_v)

        if errors:
            for e in errors:
                st.error(e)
        else:
            st.session_state.name = name.strip()
            st.session_state.age = age_v
            st.session_state.height_cm = height_v
            st.session_state.weight_kg = weight_v
            st.session_state.bp_systolic = sys_v
            st.session_state.bp_diastolic = dia_v

            new_row = {
                "date": pd.to_datetime(datetime.now().date()),
                "bp_systolic": sys_v,
                "bp_diastolic": dia_v,
                "weight_kg": weight_v,
                "height_cm": height_v,
            }
            df = st.session_state.hist_df
            if (df["date"] == new_row["date"]).any():
                idx = df.index[df["date"] == new_row["date"]][0]
                for k in ["bp_systolic", "bp_diastolic", "weight_kg", "height_cm"]:
                    df.loc[idx, k] = new_row[k]
            else:
                st.session_state.hist_df = pd.concat([df, pd.DataFrame([new_row])], ignore_index=True)

            st.success("Vitals saved. Go to Risk tab to compute prediction, or view Trends.")

    if "weight_kg" in st.session_state and "height_cm" in st.session_state:
        bmi_now = calc_bmi(st.session_state["weight_kg"], st.session_state["height_cm"])
    else:
        bmi_now = 0.0
    st.metric("Current BMI", f"{bmi_now:.2f}")

# -------------------------------
# Trends tab (time series + rolling)
# -------------------------------
with tab_trends:
    st.header("Trends and rolling averages")

    df = st.session_state.hist_df.copy().sort_values("date")
    df["bmi"] = df.apply(lambda r: calc_bmi(r["weight_kg"], r["height_cm"]), axis=1)
    df["bp_sys_roll7"] = df["bp_systolic"].rolling(7, min_periods=1).mean()
    df["bp_dia_roll7"] = df["bp_diastolic"].rolling(7, min_periods=1).mean()
    df["bmi_roll7"] = df["bmi"].rolling(7, min_periods=1).mean()

    st.write("Tip: Hover charts for values; use the Input tab daily to build history.")
    colA, colB = st.columns(2)
    with colA:
        st.subheader("Systolic BP (7d rolling)")
        st.line_chart(df.set_index("date")[["bp_systolic", "bp_sys_roll7"]])
    with colB:
        st.subheader("Diastolic BP (7d rolling)")
        st.line_chart(df.set_index("date")[["bp_diastolic", "bp_dia_roll7"]])

    st.subheader("BMI (7d rolling)")
    st.line_chart(df.set_index("date")[["bmi", "bmi_roll7"]])

# -------------------------------
# Risk tab (predict + PDF download)
# -------------------------------
with tab_risk:
    st.header("Risk assessment")

    name = st.session_state.get("name", "User")
    age = int(st.session_state.get("age", 0) or 0)
    height_cm = int(st.session_state.get("height_cm", 0) or 0)
    weight_kg = float(st.session_state.get("weight_kg", 0.0) or 0.0)
    bp_systolic = int(st.session_state.get("bp_systolic", 0) or 0)
    bp_diastolic = int(st.session_state.get("bp_diastolic", 0) or 0)

    bmi = calc_bmi(weight_kg, height_cm) if (weight_kg and height_cm) else 0.0

    i1, i2, i3, i4 = st.columns(4)
    i1.metric("Age (y)", age if age else 0)
    i2.metric("BMI", f"{bmi:.2f}")
    i3.metric("Systolic", f"{bp_systolic} mmHg" if bp_systolic else "0 mmHg")
    i4.metric("Diastolic", f"{bp_diastolic} mmHg" if bp_diastolic else "0 mmHg")

    # BP status derived from the specific entered reading now that ranges are removed
    if bp_systolic and bp_diastolic:
        bp_cat, _ = classify_bp(bp_systolic, bp_diastolic)
        bp_status_text = f"{bp_cat} (based on {bp_systolic}/{bp_diastolic} mmHg)"
    else:
        bp_status_text = "Not available"
    st.subheader(f"BP status: {bp_status_text}")

    bmi_cat, _ = classify_bmi(bmi) if bmi else ("Unknown", "")
    bmi_status_text = f"{bmi_cat} (BMI {bmi:.2f})"
    st.subheader(f"BMI status: {bmi_status_text}")

    if bp_systolic and bp_diastolic:
        heart_risk_label, _, heart_risk_reason = heart_risk_from_bp(bp_systolic, bp_diastolic)
        heart_risk_text = f"{heart_risk_label} — {heart_risk_reason}"
    else:
        heart_risk_text = "Unavailable — enter BP readings in Input tab."
    st.subheader(f"Heart risk status: {heart_risk_text}")

    model = st.session_state.model
    if age and bmi and bp_systolic and bp_diastolic:
        X_user = pd.DataFrame(
            [{"age": age, "bmi": bmi, "bp_systolic": bp_systolic, "bp_diastolic": bp_diastolic}]
        )
        pred = int(model.predict(X_user)[0])
        proba = model.predict_proba(X_user)[0] if hasattr(model, "predict_proba") else None
        st.subheader(f"Predicted tier: {risk_label(pred)}")
        if proba is not None and len(proba) == 3:
            st.write(f"Probabilities → Low: {proba[0]:.2f} • Medium: {proba[1]:.2f} • High: {proba[2]:.2f}")
    else:
        st.info("Enter valid age, height, weight, and BP in Input tab to compute prediction.")

    exp_sys, exp_dia = expected_bp_for_age(age if age else 40)
    exp_bmi = expected_bmi_mid_healthy()
    comp_df = pd.DataFrame(
        {
            "Metric": ["Systolic (mmHg)", "Diastolic (mmHg)", "BMI"],
            "Expected": [exp_sys, exp_dia, round(exp_bmi, 1)],
            "User": [bp_systolic or 0, bp_diastolic or 0, round(bmi, 1)],
        }
    )
    st.subheader("Expected vs user (by age)")
    st.caption("Expected BP based on adult age-group averages; expected BMI is midpoint of healthy adult range.")
    st.bar_chart(comp_df.set_index("Metric"))

    recs = []
    # Tailor suggestions using point BP category
    status_only = classify_bp(bp_systolic, bp_diastolic)[0] if (bp_systolic and bp_diastolic) else None
    if status_only in ["Stage 1 Hypertension", "Stage 2 Hypertension", "Hypertensive Crisis"]:
        recs += [
            "Check BP on multiple days and consider home monitoring; seek medical advice for confirmation.",
            "Limit sodium to ~2,300 mg/day (or as advised), prefer fresh foods over processed.",
            "Add daily walks and stress management; prioritize sleep quality.",
        ]
        if status_only == "Hypertensive Crisis":
            recs += ["If you have symptoms like chest pain, shortness of breath, or neuro deficits, seek urgent care."]
    elif status_only == "Elevated":
        recs += [
            "Reduce sodium, maintain healthy weight, and increase physical activity.",
            "Recheck BP periodically to ensure it does not progress.",
        ]
    elif status_only == "Low":
        recs += [
            "If symptomatic (dizziness, fainting), hydrate and consult a clinician.",
            "Review medications and recent illness if applicable.",
        ]

    if bmi and classify_bmi(bmi)[0] in ["Overweight", "Obesity"]:
        recs += [
            "Aim for 150–300 minutes of moderate activity per week.",
            "Reduce calorie-dense, low-nutrient foods; increase fiber and protein.",
        ]
    elif bmi and classify_bmi(bmi)[0] == "Underweight":
        recs += [
            "Consider nutrient-dense meals and strength training; discuss with a clinician or dietitian.",
            "Screen for causes of low weight if unintentional or symptomatic.",
        ]
    if age >= 40:
        recs += ["Schedule periodic health checkups and monitor BP regularly."]
    if not recs:
        recs = [
            "Maintain a balanced diet and regular physical activity.",
            "Sleep 7–9 hours and stay hydrated.",
        ]
    st.subheader("Personalized suggestions")
    for r in recs:
        st.write("• " + r)

    city_hint = "Kolkata"
    doctor_info = make_doctor_card(city_hint)
    payload = {
        "name": name,
        "age": age,
        "height_cm": height_cm,
        "weight_kg": weight_kg,
        "bmi": bmi,
        "bp_systolic": bp_systolic,
        "bp_diastolic": bp_diastolic,
        "pred_tier": risk_label(pred) if (age and bmi and bp_systolic and bp_diastolic) else "Unknown",
        "proba": (proba.tolist() if (age and bmi and bp_systolic and bp_diastolic and 'proba' in locals() and proba is not None) else None),
        "generated_at": datetime.now().strftime("%Y-%m-%d %H:%M"),
        "recs": recs,
        "bp_status_text": bp_status_text,
        "bmi_status_text": bmi_status_text,
        "heart_risk_text": heart_risk_text,
        **doctor_info,
    }
    pdf_bytes = build_report_pdf(payload)
    st.download_button(
        label="Download PDF report",
        data=pdf_bytes,
        file_name=f"vitals_risk_report_{name.replace(' ', '_') if isinstance(name, str) else 'User'}.pdf",
        mime="application/pdf",
    )

# -------------------------------
# Chat tab (Streamlit chat elements, grounded on session data)
# -------------------------------
with tab_chat:
    st.header("Assistant")
    st.write(
        "Ask about your inputs, risk result, or how to improve. This demo uses rules and app context (no external API)."
    )

    def answer_with_context(message: str) -> str:
        """Very simple rule-based responder grounded in current session values."""
        name = st.session_state.get("name", "User")
        age = int(st.session_state.get("age", 0) or 0)
        height_cm = int(st.session_state.get("height_cm", 0) or 0)
        weight_kg = float(st.session_state.get("weight_kg", 0.0) or 0.0)
        bp_systolic = int(st.session_state.get("bp_systolic", 0) or 0)
        bp_diastolic = int(st.session_state.get("bp_diastolic", 0) or 0)
        bmi = calc_bmi(weight_kg, height_cm) if (weight_kg and height_cm) else 0.0

        model = st.session_state.model
        if age and bmi and bp_systolic and bp_diastolic:
            X_user = pd.DataFrame(
                [{"age": age, "bmi": bmi, "bp_systolic": bp_systolic, "bp_diastolic": bp_diastolic}]
            )
            pred = int(model.predict(X_user)[0])
        else:
            pred = None

        msg = message.lower().strip()

        if "bmi" in msg:
            if bmi:
                cat, _ = classify_bmi(bmi)
                return f"{name}, your BMI is {bmi:.2f} — {cat}."
            return f"{name}, BMI is not available yet. Please enter height and weight in the Input tab."
        if "blood" in msg or "bp" in msg or "pressure" in msg:
            if bp_systolic and bp_diastolic:
                status, _ = classify_bp(bp_systolic, bp_diastolic)
                risk_lbl, _, _ = heart_risk_from_bp(bp_systolic, bp_diastolic)
                return f"Your latest BP is {bp_systolic}/{bp_diastolic} mmHg — {status}. Heart risk: {risk_lbl}."
            return "BP not available yet. Please enter systolic and diastolic values in the Input tab."
        if "risk" in msg or "result" in msg or "prediction" in msg:
            if pred is not None:
                return f"Your model tier is {risk_label(pred)}. Key drivers typically include BMI and blood pressure. Improving activity, diet quality, sleep, and stress can shift risk down."
            return "Risk prediction is not available yet. Please enter age, height, weight, and BP in the Input tab."
        if "improve" in msg or "recommend" in msg or "diet" in msg or "exercise" in msg:
            tips = []
            if bp_systolic and bp_diastolic:
                status, _ = classify_bp(bp_systolic, bp_diastolic)
                if status in ["Stage 1 Hypertension", "Stage 2 Hypertension"]:
                    tips.append("Limit sodium, add daily walks, and monitor BP at home.")
                if status == "Elevated":
                    tips.append("Optimize diet quality and recheck BP periodically.")
            if bmi:
                bmi_cat, _ = classify_bmi(bmi)
                if bmi_cat in ["Overweight", "Obesity"]:
                    tips.append("Target a modest weekly deficit and prioritize protein and fiber.")
                if bmi_cat == "Underweight":
                    tips.append("Increase nutrient-dense intake and consider strength training.")
            if not tips:
                tips.append("Maintain consistent routines: 7–9h sleep, regular meals, and activity.")
            return "Suggestions: " + " ".join(tips)
        if "hello" in msg or "hi" in msg:
            return f"Hi {name}! You can ask about BMI, BP, your risk result, or how to improve."
        return "You can ask about your BMI, BP, risk result, or how to improve. This assistant is informational only."

    # Create a container for chat messages
    chat_container = st.container()
    
    # Display all previous messages in the container
    with chat_container:
        for turn in st.session_state.chat_history:
            with st.chat_message(turn["role"]):
                st.write(turn["content"])

    # Input box appears after all messages
    prompt = st.chat_input("Type your question")
    if prompt:
        # Add user message
        st.session_state.chat_history.append({"role": "user", "content": prompt})
        # Generate assistant response
        reply = answer_with_context(prompt)
        st.session_state.chat_history.append({"role": "assistant", "content": reply})
        # Rerun to display new messages
        st.rerun()

# Footer note
st.caption("This app is a demo and does not provide medical diagnosis.")
